Browser / Postman
   ‚Üì
App A: PaymentsController
   ‚Üì
Feign Client (PaymentsProxy)
   ‚Üì   HTTP POST /payment
   ‚Üì   Header: requestId
   ‚Üì   Body: Payment JSON
App B: PaymentsController
   ‚Üì
ResponseEntity<Payment>
   ‚Üì
Feign ‚Üí Jackson ‚Üí Payment object
   ‚Üì
Returned back to App A controller



1Ô∏è‚É£ What Happens in App A (Feign Client Side)
Your controller (App A)
java
Copy code
@PostMapping("/payment")
public Payment getPayment(@RequestBody Payment payment) {
    String requestId = UUID.randomUUID().toString();
    return paymentsProxy.createPayment(requestId, payment);
}
Key idea
This line üëá is NOT a normal method call:
java
Copy code
paymentsProxy.createPayment(requestId, payment);
It looks like Java, but it actually means:

‚ÄúSend an HTTP request to another service.‚Äù

2Ô∏è‚É£ What PaymentsProxy REALLY Is
java
Copy code
@FeignClient(
    name = "payments",
    url = "${name.service.url}"
)
public interface PaymentsProxy {
    @PostMapping("/payment")
    Payment createPayment(
        @RequestHeader String requestId,
        @RequestBody Payment payment
    );
}
At startup, Spring + Feign do this:
Create a runtime proxy class
Implement this interface dynamically
Bind annotations to HTTP behavior
So Feign interprets this as:

yaml
Copy code
HTTP POST {base-url}/payment
Headers:
  requestId: <UUID>
Body:
  { "amount": 1000 }


3Ô∏è‚É£ How the URL Is Resolved
java
Copy code
url = "${name.service.url}"
From application.properties (App A):

properties
Copy code
name.service.url=http://localhost:8081
So Feign builds:

bash
Copy code
POST http://localhost:8081/payment
‚ö†Ô∏è This must match App B‚Äôs port.

4Ô∏è‚É£ Request Leaves App A (Important Part)
Feign now sends this real HTTP request:

yaml
Copy code
POST /payment HTTP/1.1
Host: localhost:8081
Content-Type: application/json
requestId: 3f2c9e...

{
  "amount": 1000
}

5Ô∏è‚É£ Request Reaches App B Controller
Your second controller:

java
Copy code
@RestController
public class PaymentsController {

    @PostMapping("/payment")
    public ResponseEntity<Payment> payment(
            @RequestHeader String requestId,
            @RequestBody Payment payment) {
Why this matches perfectly
Feign sends	App B receives
POST /payment	@PostMapping("/payment")
Header requestId	@RequestHeader String requestId
JSON body	@RequestBody Payment payment
‚úî Perfect contract match
‚úî Spring MVC maps it instantly


6Ô∏è‚É£ App B Processes the Request
java
Copy code
logger.info("Received request with id "+ requestId);
payment.setId(UUID.randomUUID().toString());
Then responds:

java
Copy code
return ResponseEntity
        .status(HttpStatus.OK)
        .header("requestId", requestId)
        .body(payment);
So the HTTP response is:

makefile
Copy code
HTTP/1.1 200 OK
requestId: 3f2c9e...
Content-Type: application/json

{
  "id": "abc-123",
  "amount": 1000
}


7Ô∏è‚É£ Response Travels Back to App A
Now Feign does the reverse:

Reads response body
Uses Jackson
Converts JSON ‚Üí Payment
Returns it from createPayment(...)

So this line in App A:
java
Copy code
return paymentsProxy.createPayment(requestId, payment);
returns a fully populated Payment object.


8Ô∏è‚É£ App A Sends Response to Client
Because App A controller is a @RestController:

java
Copy code
return Payment;
Spring converts it back to JSON and sends it to:
Browser
Postman
Frontend



One JVM ‚Üí one port
So each Spring Boot app needs:
its own run configuration
its own server.port

STEP 1Ô∏è‚É£ Open Both Apps in IntelliJ
Option A (BEST ‚Äì Recommended)
Open both projects in the same IntelliJ window:
File ‚Üí Open ‚Üí select App B ‚Üí Open as Module
Now you‚Äôll see:
Project
 ‚îú‚îÄ‚îÄ app-a-feign-client
 ‚îî‚îÄ‚îÄ app-b-payments-service
Option B
Open them in two IntelliJ windows
(also totally fine).

STEP 2Ô∏è‚É£ Set Different Ports (CRITICAL)
App B (Payments Service)
application.properties
server.port=8081

App A (Feign Client)
application.properties
server.port=8080
name.service.url=http://localhost:8081
‚úî App A calls App B
‚úî Ports don‚Äôt clash

STEP 3Ô∏è‚É£ Enable Feign in App A
In App A main class:
@SpringBootApplication
@EnableFeignClients
public class AppAApplication {
    public static void main(String[] args) {
        SpringApplication.run(AppAApplication.class, args);
    }
}


‚ö†Ô∏è Without this ‚Üí Feign client won‚Äôt work.
STEP 4Ô∏è‚É£ Create Run Configurations
Method 1 (Easiest)
Open App B
Right-click main class ‚Üí Run
Open App A
Right-click main class ‚Üí Run
‚úî IntelliJ will create two separate run configs automatically

